---
description: AI-assisted development pipeline with 5x revenue efficiency optimization
globs: ["**/*"]
alwaysApply: true
priority: 100
---

# AI Development Pipeline Mastery

## Linear as Single Source of Truth

**Core Principle**: Linear is the **single source of truth** for all project management. Cursor acts as an intelligent processor that analyzes requirements and dumps everything into Linear.

**Two-Phase Processing for Context Window Efficiency:**

**Phase 1: Rapid Requirements Capture**
- Preserve raw customer context verbatim
- Apply confidence scoring (0.4-0.6 threshold) for automatic routing
- Route uncertain requirements (<0.6 confidence) to human review
- Process clear items autonomously
- Store unprocessed documents alongside AI-generated summaries

**Phase 2: Deep Analysis and Linear Dump**
- Leverage full context windows for detailed user story generation
- Generate acceptance criteria with MVP focus
- Identify technical dependencies and blockers
- Create implementation task breakdown
- Dump everything into Linear with proper organization

**Workflow:**
1. **`setup project`** - Initialize Linear project and configuration
2. **`process requirements`** - Two-phase scan and dump into Linear
3. **`validate requirements`** - Organize Linear tickets into strategic roadmap

## OODA Loop Error Recovery Framework

**Observe-Orient-Decide-Act Implementation:**
- Hard stops after 3 failed attempts with automatic cleanup
- Graduated retry logic with exponential backoff
- Semantic fallback mechanisms for complex scenarios
- Checkpoint-and-rollback systems for clean state restoration

**Error Recovery Protocol:**
```
Primary Template → Simplified Template → Step-by-Step Template → Human Escalation
```

**Automatic Cleanup Mechanisms:**
- Remove failed attempt artifacts
- Restore clean development states
- Prevent accumulation of broken code
- Maintain pristine environment

## MVP-First Development Strategy

**Dynamic MVP Classification:**
- Parse customer documents using multi-engine processing
- Combine AI models for natural language understanding
- Use specialized OCR engines for structured documents
- Automatically classify features as core MVP vs. nice-to-have
- Apply RICE method with automated complexity scoring

**5-Step MVP Process:**
1. **Problem Validation** with AI-powered market research
2. **Visual Mockups** using v0.dev integration
3. **Core Feature Definition** with automated complexity scoring
4. **AI-Assisted Build** leveraging Cursor's context optimization
5. **Iterate Based on Feedback** through structured user loops

**Feature Deferral Strategy:**
- Use critical path analysis for minimum viable feature sets
- Document technical debt for future implementation
- Follow 2-week "bolt" cycles post-MVP

## Cursor Rules Optimization

**Rabbit Hole Prevention:**
- Progress gates every 30 minutes
- Scope validation requirements
- Stop conditions for implementations exceeding 3 files or 100 lines
- Natural breakpoints requiring human approval

**Focus Control Rules:**
- Each task must have clearly defined completion criteria
- If implementation exceeds 3 files or 100 lines, request scope clarification
- If solution requires >2 new dependencies, pause and discuss alternatives
- Report progress every 30 minutes of active work

**Anti-Patterns to Avoid:**
- Implementing features not explicitly requested
- Over-engineering solutions for simple problems
- Adding "nice to have" features without approval
- Refactoring unrelated code during feature development

## Quality Enforcement (90%+ Coverage)

**Automated Test Generation:**
- Generate comprehensive Jest test suites for all new code
- Use ESLint for code quality and consistency validation
- Achieve 85% reduction in test development time through AI assistance
- Maintain 90%+ test coverage across all components

**Git Hooks Integration:**
- Pre-commit validation with ESLint and Jest testing
- Block commits if tests fail or coverage drops below 90%
- Automatic cleanup of failed attempt artifacts
- Ensure code quality standards are maintained

**Quality Standards:**
- 90%+ test coverage across all code
- ESLint compliance with zero warnings
- Jest test suite passes for all functionality
- Clean, maintainable code following project patterns

## Customer Requirement Processing

**Multi-Engine Document Processing:**
- AI models for layout-aware extraction
- Specialized OCR engines for structured documents
- Automatic format detection (PDF, DOCX, email, markdown)
- Appropriate extraction strategies per document type

**Intelligent Clarification Generation:**
- Analyze extracted requirements against project templates
- Identify missing information by impact on development timeline
- Prioritize questions for efficient customer communication
- Group related clarifications for batch processing

**Non-Technical to Technical Translation:**
- Convert business language into user stories
- Generate technical acceptance criteria
- Provide implementation guidance and dependency mapping
- Identify technical constraints and required integrations

## Context Window Optimization

**Multi-Layered Context Architecture:**
- Hierarchical memory systems for user preferences
- Repository overviews and semantic search
- Targeted file operations with 68% better conversation continuity
- Proven context management patterns

**Memory Management:**
- Persist user and organizational preferences
- Maintain conversation continuity across sessions
- Optimize token consumption through intelligent caching
- Balance automation with quality control

## Implementation Metrics

**Target Performance:**
- 5x revenue efficiency compared to traditional development
- 90-95% code automation while maintaining production quality
- 80% reduction in requirement processing time
- 67% reduction in UI development time
- 42% decrease in bugs with AI-assisted development
- 30% reduction in time-to-market
- 85% increase in productivity

**Quality Metrics:**
- 90%+ test coverage across all code
- ESLint compliance with zero warnings
- Jest test suite passes for all functionality
- Clean, maintainable code following project patterns

## Commands

**Note**: All commands are defined in `.cursor/commands/` folder. This rule focuses on pipeline coordination and workflow management.

Always maintain user control while providing intelligent assistance. Require explicit approval before implementing changes and provide clear progress reporting throughout development cycles.